<!DOCTYPE html>
<html>
  <head>
    <title>Title</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
    </style>
  </head>
  <body>
    <textarea id="source">
# Intro a bash

Bash es un lenguaje de programación atípico. Sí, es un lenguaje de programación. Su fortaleza está
en invocar distintos programas y hacer que interoperen entre ellos.

Además viene con un conjunto de herramientas para estos casos de uso que son muy convenientes.

---

Un ejemplo, sacado de [Quora](https://www.quora.com/Is-learning-bash-programming-valuable), ilustra
estos beneficios:

Si queremos buscar las 10 palabras más comunes en un archivo de texto, la solución en Python podría
ser algo así

```python
from collections import defaultdict
from string import punctuation

wordcount = defaultdict(int)

for line in open('hamlet.txt'):
    line = ''.join([char for char in line.lower()
                   if char not in punctuation])
    for word in line.split():
        wordcount[word] += 1

for key in sorted(wordcount, key=wordcount.get, reverse=True)[:10]:
    print(key, wordcount[key])
```

La solución en bash por otro lado

```bash
tr A-Z a-z < hamlet.txt | tr -sc a-z '\n' | sort | uniq -c | sort -rn | head
```

Por supuesto es más legible, aún sin saber Python, la primera respuesta que la segunda pero se ve
que esta última es bastante más concisa.

---

# Flujo de control, variables y matemática

Antes de empezar vamos a poner como convención la nomeclatura

```bash
$ echo Hello world
Hello world
$
```

Como convención las líneas que empiezan con `$` son comandos que se introducen (siendo `$` el
"prompt" del usuario) y las que le siguen la salida del comando. También si en algún momento se usa
`#` en vez de `$` estamos hablando de un prompt de `root`, el super usuario de la computadora.

`echo` es un comando de Bash para recibir argumentos (que aparecen en la misma línea, en el ejemplo
"Hello world") y escribir en la salida del programa los mismos argumentos.

---

## Variables

Para definir una variable hay que poner `variable=valor` sin espacios. Después si queremos ver el
valor de esa variable usamos `$variable`.

```bash
$ salute=Hello
$ echo $salute world
Hello world
```

Las variables siempre son strings (excepto los arrays, que son usados raramente) entonces
`var=Hello` y `var="Hello"` son equivalentes.

Si queremos que el valor tenga espacios necesitamos obligatoriamente usar comillas, sino son
opcionales.

Por defecto cualquier variable que querramos usar que no tenga ningún valor va a contener un valor
vacío.

---

### `export`

Algunas veces vamos a ver que antes de asignar un valor a una variable se antepone la palabra
`export`. Esto permite que la variable se propague hacia los subprocesos como variable de entorno.
El concepto de subproceso lo vamos a ver más en detalle luego.

```bash
$ salute_noexport=hello
$ bash -c 'echo $salute_noexport'

$ export salute_export=hello
$ bash -c 'echo $salute_export'
hello
```

Por convención las variables se escriben en minúsculas excepto las de entorno que se usan
completamente en mayúsculas.

---

## `if`

Para ejecutar sentencias en ciertas condiciones se usa `if cond; then statments; fi`. El `;` marca
el final de una sentencia al igual que un salto de línea.

Por ejemplo.

```bash
$ value=3
$ if [ $value == 3 ]; then echo "el valor es tres"; fi
```

```bash
$ value=3
$ if [ $value == 3 ]; then echo "el valor es tres"; else echo "el valor no es tres"; fi
el valor es tres
$ value=4
$ if [ $value == 3 ]; then echo "el valor es tres"; else echo "el valor no es tres"; fi
el valor no es tres
```

---

También podemos ver si un valor es mayor que otro pero hay que tener cuidado porque como los
valores siempre son strings se lo compara alfabéticamente

```bash
$ if [ 20 -gt 3 ]; then echo "20 > 3"; fi
20 > 3
```

También se puede comparar inequidad (`!=`), mayor o igual (`-ge`), menor (`-lt`), menor o igual
(`-le`). Muchas más opciones están disponibles, se pueden ver ejecutando `man [`.

---

### Múltiples condiciones

Se puede usar `and` y `or` para evaluar múltiples condiciones. En ese caso, cada una tiene que
estar entre corchetes.

```bash
$ if [ 20 -gt 3 ] && [ 4 == 4 ] || [ 5 == 4 ]; then echo "20 > 3 && 4 == 4 || 5 == 5"; fi
20 > 3 && 4 == 4
```

Para agrupar términos se pueden usar paréntesis.

```bash
$ if [ 4 == 4 ] && ( [ 3 == 3 ] || [ 5 == 4 ] ); then echo OK; fi
OK
$ if [ 4 == 4 ] && ( [ 3 == 2 ] || [ 5 == 4 ] ); then echo OK; fi
```

---

### `elif` y `else`

```bash
$ if [ 3 == 4 ]; then echo OK; else echo not OK; fi
not OK
$ if [ 3 == 4 ]; then echo OK; elif [ 5 -gt 4 ] echo not OK; fi
not OK
```

---

## `for`

Para iterar existe el `for` que en realidad funciona más como un `foreach`. La sintaxis es
`for variable in list; do statements; done`

```bash
$ for value in a b c d e f; do echo $value; done
a
b
c
d
e
f
```

Esto se puede usar en conjunto con _brace expansion_ para iterar una cantidad determinada de veces

```bash
$ for value in {a..f}; do echo $value; done
a
b
c
d
e
f
```

---

## Matemática

Para hacer operaciones matemáticas se usa `$(( math ))`.

```bash
$ echo $(( 10 + 3 * 2 ))
16
```

---

# Tarea

## Fizz buzz

Escribir un programa que muestre en pantalla los números del 1 al 100, sustituyendo los múltiplos
de 3 por el palabro "Fizz" y, a su vez, los múltiplos de 5 por "Buzz". Para los números que, al
tiempo, son múltiplos de 3 y 5, utiliza el combinado "FizzBuzz".

Empezaría algo así:

```
1
2
Fizz
4
Buzz
Fizz
7
8
Fizz
Buzz
11
Fizz
13
14
FizzBuzz
16
...
```

---

# Subcomandos, entrada, salida

## Pipe

Cuando ejecutamos una sentencia en bash podemos usar la salida de un comando como entrada de
otro.

Por ejemplo podemos invocar `wc`, un comando que cuenta la cantidad de líneas, palabras y y bytes,
con "hello world"

```bash
$ echo hello world |wc
      1       2      12
```

El pipe (`|`) agarra la salida del comando de la izquierda y la usa como entrada del comando de la
derecha. También se puede encadenar

```bash
$ echo hello world |wc |wc
      1       3      24
```

En este caso está mostrando que la salida del primer `wc` tiene 24 bytes en 3 palabras (1, 2 y 12).

---

## Redirigir salida

Se puede hacer que bash guarde la salida de un programa directamente en un archivo. Con `cat`
podemos leer el contenido de un archivo.

```bash
$ echo "Hello world" > myfile
$ cat myfile
Hello world
```

### _append_

Si ponemos un solo `>` el archivo se vacía al invocarlo, pero si se usa `>>` no sino que agrega al
final.

```bash
$ echo "1" > myfile
$ echo "2" >> myfile
$ echo "3" >> myfile
$ cat myfile
1
2
3
```

---

### `/dev/null`

Hay un archivo especial en sistemas UNIX que es `/dev/null` que es un archivo que siempre está
vacío y escribir en él no hace nada. Se usa cuando uno quiere descartar la salida del programa.

### `/dev/urandom`

Otro archivo especial es `/dev/urandom` que genera contenido aleatorio constantemente. Si bien es
un archivo, es un archivo que cada vez que se lee genera distintos datos infinitamente.

---

## stdout, stderr

Cuando hablamos de la salida de un programa en realidad hablabamos del `stdout`, pero el mismo
programa también puede escribir cosas en otra salida llamada `stderr`. Esta última se usa para
notificar de cosas que no son la respuesta en sí. Por ejemplo al ejecutar `ls <path>` esperamos
ver el contenido del archivo o directorio en `<path>`, pero si éste no existe vemos un mensaje
que nos avisa de esto. Si esto fuese interpretado como la salida del programa, podríamos cometer
un error en nuestro código.

Ejemplo:

```bash
$ ls 02-subcomandos/README.md 
02-subcomandos/README.md
$ ls 02-subcomandos/no-existo 
ls: cannot access '02-subcomandos/no-existo': No such file or directory
$ ls 02-subcomandos/README.md > /dev/null 
$ ls 02-subcomandos/no-existo > /dev/null 
ls: cannot access '02-subcomandos/no-existo': No such file or directory
```

Vemos que aún habiendo redirigido la salida de `ls` recibimos el mensaje de error correspondiente.
De la misma forma si pasamos el resultado de este `ls` por `wc` va a decir que estaba vacío.

---

## stdin

Como tenemos estas dos salidas también tenemos la entrada. Ya escribimos en eso usando pipes antes,
pero también podemos escribir en ella desde un archivo usando `<`

```bash
wc < 02-subcomandos/README.md 
  86  428 2543
```

También se puede usar `<<` para un _here-document_ que lee hasta encontrar un indicador de final
del documento, y `<<<` para un _here-string_ que lee hasta terminar el string, y esto se manda al
_stdin_ del programa.

```bash
$ wc <<EOF
> read
> until
> find
> EOF
 3  3 16
$ wc <<<"read one string"
 1  3 16
$
```

---

## Código de salida

Cuando un programa termina de ejecutarse pudo haber concluído con éxito o no. Esto se indica por
un código de salida que podemos acceder usando `$?` inmediatamente después del comando.

```bash
$ ls 02-subcomandos/README.md > /dev/null 
$ echo $?
0
$ ls 02-subcomandos/no-existo > /dev/null
ls: cannot access '02-subcomandos/no-existo': No such file or directory
$ echo $?
2
```

Un código 0 indica éxito. Uno distinto a 0 indica fallo. Cada comando establece el significado de
los distintos valores posibles.

---

Los condicionales que usamos en el if en realidad usan esto para evaluar.

```bash
$ [ 1 == 1 ]
$ echo $?
0
$ [ 1 == 2 ]
$ echo $?
1
```

Entonces podemos usar cualquier comando para ver si tiene éxito como condición en un `if`. Por
ejemplo si queremos ver si un archivo contiene una cadena:

```bash
$ if grep -q "cadena" README.md; then echo "contiene!"; fi
```

Acá usamos `grep` que devuelve 0 sólo si se encuentra la cadena en el archivo.

---

# Tarea

## Contar palabras

Contar cuántas palabras hay en el Zen de Python, que se obtiene al ejecutar
`python -m this`. Si queremos ver la cantidad de palabras podemos usar `wc -w`,
para cantidad de líneas `wc -l`; más información en `man wc`.

## Pasar el zen a mayúsculas

Volver a obtener el Zen de Python y pasarlo completamente a mayúsculas.

## Hashear una cadena aleatoria

Leer 60 bytes aleatorios y calcular el sha1. Usar `head` y `sha1sum`.

---

## Mostrar la hora aleatoriamente

Cada un segundo mostrar la hora actual con un 50% de probabilidad.
`while true; do statements; done` se puede hacer un loop infinito. Con `date` se puede imprimir la
fecha. La variable `RANDOM` tiene un valor diferente cada vez que se lee en el rango de 0 a 32767.
Para que sea sólo una vez por segundo se puede usar la función `sleep`.

---

# Utilitarios

Las comandos built-in y los programas comunes de UNIX son una parte fundamental para poder usar
bash. Algunas ya aparecieron: `cat`, `grep`, `wc`, `ls`, `head`, `tr`.

## `man` y `--help`

Se acostumbra que los comandos traigan ayuda al agregarle el parámetro `--help`, por ejemplo
`grep --help`. Para más información se puede acceder al manual con `man grep`.

---

## Archivos

### `find`

Sirve para encontrar archivos o directorios, en general por nombre. Por ejemplo
`find . -name 0\* -type f` va a encontrar todos los archivos que estén en este directorio o sus
subdirectorios y empiecen por 0.

### `df`

Muestra las distintas particiones montadas, cuánto espacio libre y ocupado tienen. Con `-h` usa
unidades "leíbles por humanos" como kilo, mega,
giga

### `du`

Lista todos los archivos y directorios en este directorio recursivamente y cuánto ocupan. Con `-s`
da sólo el resumen del directorio. A diferencia de `df` esto puede tardar porque hace la suma
archivo por archivo.

---

## Texto

### `tail`

Así como `head`, `tail` lee las últimas líneas o bytes de un archivo. Usando `tail -f` el archivo
permanece abierto y si se le agrega información va a ir apareciendo.

```bash
$ for i in {1..10}; do echo $i >> file; done
$ tail -n 3 file
8
9
10
$
```

```bash
$ tail -n 3 -f file
8
9
10
```

En este caso el proceso no concluye. Si en otra terminal ejecutamos `echo 11 >> file` vamos a ver
cómo se agrega la nueva línea.

---

### `sort`

Ordena las líneas recibida alfabéticamente.

```bash
$ rm -f file; for i in {1..20}; do echo $i >> file; done
$ sort file
1
10
11
12
13
14
15
16
17
18
19
2
20
3
4
5
6
7
8
9
```

---

También se puede hacer comparaciones numéricas

```bash
$ sort -n file
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
```

---

### `uniq`

Sirve para deduplicar líneas consecutivas.

```bash
$ rm -f file; for i in {1..3}; do echo $i >> file; echo $i >> file; done
$ cat file
1
1
2
2
3
3
$ uniq file
1
2
3
```

También se puede usar `uniq -c` para contar la cantidad de repeticiones.

```bash
$ rm -f file; for i in {1..3}; do echo $i >> file; echo $i >> file; done
$ uniq -c file
      2 1
      2 2
      2 3
```

---

### `awk`

Gawk es un lenguaje de programación pero en general en Bash se lo usa para extraer una columna de
un csv.

Por ejemplo

```bash
$ printf "1 2 3 4\n5 6 7 8\n9 10 11 12\n" |awk '{ print $3 }'
3
7
11
```

---

## Procesos

### `top`

`top` muestra los procesos activos que más recursos están consumiendo y el estado de los recursos
en general. Permite reconocer qué está pasando a simple vista si algo no anda bien.

### `ps`

Permite ver la lista de procesos corriendo de forma no interactiva. En general se usa con varios
parámetros como `ps aux`. Cada proceso tiene un PID que es un identificador único en el sistema
operativo

### `kill`

`kill` le manda una señal a un proceso identificador por PID. Por defecto la señal es de que salga
pero se pueden mandar otras.

---

# Tarea

## Contar ocurrencias de palabras

Buscar cuáles son las cinco palabras que aparecen más veces en el Zen de Python.

---

## Contar la cantidad de archivos en un directorio

Mostrar cuántos archivos salen de un directorio incluyendo subdirectorios.
Por ejemplo

```bash
$ mkdir a
$ mkdir a/b
$ echo "" > a/b/c
$ echo "" > a/b/d
$ mkdir e
$ echo "" > e/f
$ echo "" > e/g
$ echo "" > e/h
```

En este caso debería mostrar 2 para `a` y 3 para `e`.

## Procesos consumiendo CPU%

Con `ps aux` buscar los procesos que más CPU están consumiendo. Mostrar su PID y el comando.

---

# Script files

Bash se puede usar de forma interactiva con la consola, pero también se usan archivos con los
comandos.

## shebang

Estos archivos _tienen_ que empezar con `#!` seguido por el comando con el cual se puede
interpretar, en general `#!/bin/bash` o `#!/usr/bin/env bash`. Cualquier programa que interprete
programas puede ser usado, entonces si el archivo empieza por ejemplo con `#!/usr/bin/env python`
al ejecutar el archivo se va a invocar python.

## Permisos

Para poder ejecutar un programa el archivo tiene que tener permisos de ejecución. Cada archivo en
sistemas tipo UNIX tiene permisos asociados. Los permisos pueden ser de ejecución, lectura, y
escritura, y pueden ser otorgados al dueño del archivo, al grupo dueño del archivo o a los demás.
Esto se suele resumir en tres números del 0 al 7 inclusive.

---

Para ver los permisos de un archivo podemos usar `ls -l`

```bash
$ touch file
$ chmod 000 file
$ ls -l file
---------- 1 sebastianwaisbrot sebastianwaisbrot 0 jun 27 15:18 file
```

Acá le sacamos todos los permisos, por eso los guiones a la izquierda. Y después vemos el dueño,
el grupo duseño, el tamaño, fecha de última modificación y nombre.

Si queremos agregarle un permiso podemos darselo al usuario (_u_), al grupo (_g_) o a los otros
(_o_), y el permiso puede ser de lectura (_r_), escritura (_w_) o ejecución (_x_).


```bash
$ chmod ug+rw file
$ chmod u+x file
$ ls -l file
-rwxrw---- 1 sebastianwaisbrot sebastianwaisbrot 0 jun 27 15:18 file
```

En este caso le dimos permiso de lectura y escritura al usuario y al grupo, y de ejecución sólo al
usuario.

Una vez que el archivo tiene su shebang y permisos, se puede ejecutar con `./myscript`. Por
convención los nombres de archivos bash suelen terminar en `.sh` pero no es necesario.

---

### `sudo`

Algunos comandos requieren permisos de _superusuario_ para correr. Si corren así pueden hacer
_cualquier cosa_ en el sistema: abrir servidores en puertos privilegiados (como el 80 o 443),
modificar archivos de configuración de otros programas, modificar el sistema operativo, ver y
cambiar archivos de otros usuarios del mismo sistema.

Por ejemplo si quiero empezar un servidor web en el puerto 80 no voy a poder sin sudo

```bash
$ python -m SimpleHTTPServer 80
Traceback (most recent call last):
...
socket.error: [Errno 13] Permission denied
$ sudo python -m SimpleHTTPServer 80
[sudo] password for sebastianwaisbrot:
Serving HTTP on 0.0.0.0 port 80 ...
```

Ahora bien, si cuando recibimos un `Permission denied` agregamos `sudo` puede que el comando se
ejecute con éxito pero si el problema podía ser resuelto sin eso quizás era mejor, porque por
ejemplo el dueño de cualquier archivo creado usando `sudo` va a ser `root` y no nuestro usuario.

---

Idealmente cuando pase esto hay que entender qué es lo que quiso hacer el programa, por qué
necesitaba permisos especiales y pensar en base a eso cuál es la mejor solución.

---

## Parámetros

Cuando se invoca al script se le pueden pasar parámetros, por ejemplo `./myscript test`. Estos
aparece en algunas variables mágicas: `$0` es el nombre del archivo ejecutado, `$1` el primer
parámetro, `$2` el segundo, etc. También `$#` es la cantidad de parámetros recibidos y `$*` son
todos los parámetros (equivalente a `$1 $2 $3 $4...`).

```bash
$ echo 'echo "cantidad de argumentos: $#"' > myscrit
$ printf '"longitud del primer argumento: "; echo -n $1|wc -c' >> myscript
$ chmod a+x myscript
$ ./myscript hello
cantidad de argumentos: 1
longitud del primer argumento: 5
$ ./myscript hello world
cantidad de argumentos: 2
longitud del primer argumento: 5
```

---

## `set`

El manejo de errores en bash es peculiar. No hay excepciones y depende mucho del _exit status_ de
cada invocación. Por defecto los errores se ignoran y hay que chequearlo cada vez, o cambiar ciertas
opciones para simplificarlo.

### `set -e`

Por defecto un script va a correr hasta el final, independientemente de si algún comando falle. En
general, si algo falla puede hacer que lo que siga no funcione o peor aún funcione incorrectamente.
Por ejemplo, si cambiamos de directorio (`cd`) y después queremos borrar algún directorio de ahí
(`rm -rf <directory>`), si el primer comando falló, por ejemplo si el directorio no existe, el
segundo comando puede borrar un directorio de otro lugar, una acción destructiva no reversible.

---

Para evitar estos errores se puede configurar al archivo para que falle frente al primer fallo.

```bash
#!/bin/bash
set -e # sin esta linea, `expected-dir` sería borrado en este directorio si cd falló
cd non-existent-directory
rm -rf expected-dir
```

---

### `set -o pipefail`

Algo parecido pasa con los pipes. Si hacemos `cmd1 |cmd2` y `cmd1` falla el error se pierde.

```bash
$ cat test
#!/bin/bash
set -e
ls non-existant|cat
echo "todo bien"
$ ./test
ls: cannot access 'non-existant': No such file or directory
todo bien
```

```bash
$ cat test
#!/bin/bash
set -e
set -o pipefail
ls non-existant|cat
echo "todo bien"
$ ./test
ls: cannot access 'non-existant': No such file or directory
```

---

### `set -u`

Si usamos una variable no definida por defecto va a ser reemplazada por un valor vacío. A veces esto
está bien pero a veces no, especialmente si metimos un typo en el nombre de la variable :).
Entonces se puede hacer que el script falle si se usa una variable no definida.

```bash
$ cat test
#!/bin/bash
set -eo pipefail
echo $myvar
$ ./test

$ echo $?
0
```

```bash
$ cat test
#!/bin/bash
set -euo pipefail
echo $myvar
$ ./test
./test: line 3: myvar: unbound variable
$ echo $?
1
```

---

Si queremos usar una variable que puede no estar definida podemos usar `${myvar:-default}`. Por
ejemplo

```bash
$ cat test
#!/bin/bash
set -euo pipefail
echo ${myvar:-hello world}
$ ./test
hello world
$ echo $?
0
```

```bash
$ cat test
#!/bin/bash
set -euo pipefail
myvar="foo"
echo ${myvar:-hello world}
$ ./test
foo
$ echo $?
0
```

---

## Link simbólicos

En UNIX hay archivos especiales que son links simbólicos. Estos archivos no tienen un contenido
propio sino que redirigen a otro archivo. Se crean con `ln -s <target> <source>`

```bash
$ echo hello > file1 # creo file1
$ ln -s file1 file2 # creo file2 apuntando a file1
$ cat file2 # verifico que file2 apunta a file1
hello
$ ls -l # en ls aparecen vinculados
total 4
-rw-rw-r-- 1 sebastianwaisbrot sebastianwaisbrot 6 jul  4 12:21 file1
lrwxrwxrwx 1 sebastianwaisbrot sebastianwaisbrot 5 jul  4 12:21 file2 -> file1
$ echo helloooo >> file2 # escribir en file2 modifica file1
$ ls -l
total 4
-rw-rw-r-- 1 sebastianwaisbrot sebastianwaisbrot 15 jul  4 12:21 file1
lrwxrwxrwx 1 sebastianwaisbrot sebastianwaisbrot  5 jul  4 12:21 file2 -> file1
$ cat file1 # verifico que se escribió
hello
helloooo
```

---

```bash
$ rm file1
$ ls -l # aún habiendo borrado file1, file2 sigue existiendo apuntando a un archivo que ya no existe
total 0
lrwxrwxrwx 1 sebastianwaisbrot sebastianwaisbrot 5 jul  4 12:21 file2 -> file1
$ cat file2 # aunque file2 existe, como file1 no existe más, al tratar de leerlo dice que no existe
cat: file2: No such file or directory
```

---

## Subcomandos

Si queremos dentro de un script ejecutar un comando y guardar su salida se puede hacer usando
`$(subcommand)`. Por ejemplo

```bash
$ chars=$(echo hello|wc -c)
$ echo $chars
6
$ if [ $chars -gt 3 ]; then echo "longer than 3"; fi
longer than 3
```

---

## Expresiones regulares

Una expresión regular sirve para ver si un texto cumple con un formato determinado.
En esta página se pueden probar distintas opciones: https://regex101.com/r/AlxVE6/2

Se puede verificar si un valor cumple con una expresión regular usando esta forma
`[[ valor =~ regex ]]`.

```bash
$ if [[ hel.lo =~ ^[A-Za-z0-9]+$ ]]; then echo alphanumeric; fi
$ if [[ hello =~ ^[A-Za-z0-9]+$ ]]; then echo alphanumeric; fi
alphanumeric
```

---

# Tarea

## Cambiar comportamiento por nombre de script

Hacer un script que si se lo invoca como `fizz <num>` escriba "ok" si `num` es múltiplo de 3, si
se lo invoca como `buzz <num>` escriba "ok" si `num` es múltiplo de 5 y si se lo llama
`fizzbuzz <num>` escriba "ok" si es múltiplo de ambos 3 y 5. Tiene que ser un sólo script que cambie
su comportamiento según cómo se invoca.

---

```bash
$ ls -l
total 4
-rwxrwxr-x 1 sebastianwaisbrot sebastianwaisbrot 517 jul  4 12:57 00_fizzbuzz.sh
lrwxrwxrwx 1 sebastianwaisbrot sebastianwaisbrot  14 jul  4 12:36 buzz -> 00_fizzbuzz.sh
lrwxrwxrwx 1 sebastianwaisbrot sebastianwaisbrot  14 jul  4 12:36 fizz -> 00_fizzbuzz.sh
lrwxrwxrwx 1 sebastianwaisbrot sebastianwaisbrot  14 jul  4 12:37 fizzbuzz -> 00_fizzbuzz.sh
$ ./00_fizzbuzz.sh 1
usage: fizz <num>
usage: buzz <num>
usage: fizzbuzz <num>
$ ./fizz 3
OK
$ ./fizz 5
$ ./buzz 3
$ ./buzz 5
OK
```

---

## Servir el contenido del directorio actual en un puerto determinado

Se puede usar `python -m SimpleHTTPServer [port]` para servir el contenido del directorio actual
en un servidor web. Hacer un script que reciba un puerto opcionalmente y levante un servidor en
ese puerto. Si el puerto es menor a 1024 necesita `sudo` para correr. Por defecto debe correr en
el puerto 80.

---

# Background, funciones y aliases

## Background

Cuando ejecutamos un comando la ejecución se frena hasta que éste haya finalizado.

Por ejemplo

```bash
$ sleep 5
$ echo "tardé 5 segundos"
tardé 5 segundos
```

Cuando el comando corre así se dice que está en _foreground_. En contraste se puede ejecutar en
_background_ agregado un _&_ al final de la línea.

```bash
$ sleep 5 &
[1] 19108
$ echo "tardé 5 segundos"
tardé 5 segundos
```

En este caso el sleep devolvió el control inmediatamente y siguió corriendo sin frenar la
ejecución.

---

### Reanudar

Si iniciamos un programa en _foreground_ y queremos mandarlo a _background_ se puede hacer con
CTRL+Z. Esto lo va a frenar también. Para reanudarlo se puede ejecutar `bg`. Para devolverlo a
_foreground_, `fg`.

```bash
$ sleep 5
^Z
[1]+  Stopped                 sleep 5
$ bg
[1]+ sleep 5 &
$ fg
sleep 5
$
```

---

### Listar

Podemos ver la lista de procesos que estamos corriendo en _background_ con `jobs`. Si tenemos más
de uno nos da un índice para referenciarlos en `fg` y `bg`.

```bash
$ sleep 20
^Z
[1]+  Stopped                 sleep 20
$ sleep 30
^Z
[2]+  Stopped                 sleep 30
$ jobs
[1]-  Stopped                 sleep 20
[2]+  Stopped                 sleep 30
$ bg 2
[2]+ sleep 30 &
$ fg 1
sleep 20
$ jobs
[2]+  Running                 sleep 30 &
$ fg
sleep 30
$
```

---

### Desheredar

Estos procesos están asociados a la terminal que estamos corriendo, así que si la cerramos se
terminan. Con `disown` podemos "desheredar" un trabajo que está en background.

```bash
$ sleep 30 &
[1] 19327
$ disown
$ jobs
$
```

---

### PID

Si iniciamos un proceso en background podemos ver su PID si en la línea inmediatamente siguiente
leemos la constante `$!`.

```bash
$ sleep 30 &
[1] 19419
$ pid=$!
$ ps axu |grep $pid
sebasti+ 19419  0.0  0.0   9808   704 pts/19   S    12:39   0:00 sleep 30
sebasti+ 19426  0.0  0.0  16744   972 pts/19   S+   12:39   0:00 grep --color=auto 19419
```

---

## Funciones

Podemos agrupar comandos en funciones.

```bash
#!/bin/bash
set -euo pipefail
function hello_world() {
    echo "Hello world!"
}
hello_world
```

---

### Local vs global

Para declarar variables locales hay que anteponer la _keyword_ `local`, sino son globales.

```bash
#!/bin/bash
set -euo pipefail
function set_vars() {
    foo=1
    local bar=2
}
echo ${foo:-0} # 0
echo ${bar:-0} # 0
set_vars
echo ${foo:-0} # 1
echo ${bar:-0} # 0
```

---

### Retorno

El valor de retorno de una función es equivalente al valor de retorno de un programa, o sea que sólo
puede ser un número de 0 a 255 e indica 0 para éxito.

```bash
#!/bin/bash
set -euo pipefail

function returnsomething() {
    return 0
}
function returnsomethingelse() {
    return 1
}
returnsomething
returnsomethingelse
echo "unreachable" # como la línea anterior devolvió un código de error el script terminó
```

---

### Parámetros

Los parámetros de una función funcionan como los de un script: `$#` para la cantidad, `$0` para el
nombre de la función, `$1` para el primer argumento...

```bash
#!/bin/bash
set -euo pipefail

function print_first() {
    echo ${1:-}
}
print_first first second third
```

---

### Testear archivos

Se puede usar como condición de un `if` que un archivo exista, o directorio exista, o que sea
ejecutable.

```bash
$ file=/bin/bash
$ if [ -f "$file" ]; then echo $file exists; fi
/bin/bash exists
$ if [ -x "$file" ]; then echo $file is executable; fi
/bin/bash is executable
$ if [ -d "$file" ]; then echo $file is a directory; fi
$ file=/bin
$ if [ -f "$file" ]; then echo $file exists; fi
$ if [ -x "$file" ]; then echo $file is executable; fi
/bin is executable
$ if [ -d "$file" ]; then echo $file is a directory; fi
/bin is a directory
$
```

Hay más opciones disponibles que se pueden ver en `man [`.

---

## Aliases

Si queremos hacer una función muy sencilla podemos simplemente hacer un alias. Por ejemplo

```bash
$ alias st='git status --short'
$ st
 M 05-background-y-funciones/README.md
$
```

---

# Tarea

## Hacer un service manager simplificado

Un service manager se encarga de iniciar, detener y mostrar el estado de distintos servicios. En
Ubuntu por ejemplo viene uno que podemos ver con comandos como `service networking status`.

Cada ejecutable del directorio `services` es un programa que queremos ofrecer como servicio. La idea
es crear un programa `service` que se encargue de manejar estos servicios. Cada servicio puede
estar corriendo o no en un momento, y desde `service` se debe poder frenar o iniciar
respectivamente.

---

### `service --help`

Ayuda de cómo usar este programa

```bash
$ ./service --help
usage: ./service <service> [start|stop|status]
usage: ./service list
$
```

### `service list`

Tiene que mostrar una lista de servicios disponibles

```bash
$ ./service list
service: connection-checker
service: home-web-server
service: vpn-checker
$
```

---

### `service <service> status`

Muestra si un programa está corriendo o no

```bash
$ ./service vpn-checker status
vpn-checker is not running
$
```
o

```bash
$ ./service vpn-checker status
vpn-checker is running
$
```

### `service <service> start`

Inicia el servicio. Guarda el PID en `/tmp/services-$service.pid`. Guarda el standard output del
programa en `/var/log/services/$service.out` y el standard error en
`/var/log/services/$service.err`.

```bash
$ ./service vpn-checker start
vpn-checker started
```

---

### `service <service> stop`

Frena el servicio. Borra el _pidfile_.

```bash
$ ./service vpn-checker stop
vpn-checker stopped
```

---

### Casos inesperados

#### Parámetros incorrectos

Si el nombre del servicio o los parámetros no corresponden hay que mostrar un mensaje de error
indicando el problema y salir con un código de error.

#### PID apunta a un proceso que no existe

El PID del PID file puede no existir más (por ejemplo si el proceso se termino). En ese caso el
estado debería ser detenido.

#### Proceso no arranca

Si se inicia el servicio pero el programa sale inmediatamente hay que mostrarlo cuando se quiere
arrancar.

```bash
$ ./service bad-service start
bad-service failed to start
```

---

#### Proceso no se detiene

Para detener un proceso se manda una señal `TERM` que le indica que salga. El programa puede no
salir, en ese caso se puede mandar una señal `KILL` que fuerza a salir.

```bash
$ time ./service unstoppable stop
unstoppable stopped
./service unstoppable stop  0,11s user 0,25s system 14% cpu 2,571 total
```

No se ve cómo salió pero sí que tardó. Los primeros dos segundos fueron esperando que la señal
`TERM` haga salir al programa, después de un tiempo le mandamos un `KILL`.

---

# Strings, variables mágicas y archivos especiales

## Strings

Se pueden hacer ciertas modificaciones sencillas de texto.

### Medir longitud

```bash
$ myvar="hello world"
$ echo ${#myvar}
11
$
```

### Obtener una subcadena por índices

```bash
$ echo ${myvar:3:6}
lo wor
$ echo ${myvar:(-5)}
world
$
```

---

### Sustitución

```bash
$ myvar="hello world"
$ echo ${myvar/o/a}
hella world
$ echo ${myvar//o/a}
hella warld
$
```

### Expresiones regulares

```bash
$ expr "hello world" : '.*\(w.\+l\).*'
worl
$ expr "hello world" : '.*\(.\+o\)'
wo
$ expr "hello world" : '\(.\+o\)'
hello wo
$
```

---

## Variables mágicas

Ya vimos algunas variables mágicas antes, como `$1` y `$RANDOM`. Hay otras globales importantes
de conocer.

### `$HOME`

El usuario activo tiene que tener un directorio _home_. Esta variable contiene la ruta absoluta.

### `$USER`

Nombre del usuario activo.

---

### `$PWD`

Ruta en la cual el usuario está al ejecutar este comando. Esto no necesariamente es la ruta
donde está en archivo.

```bash
$ echo 'echo $PWD' > testing
$ chmod a+x testing
$ ./testing
/home/sebastianwaisbrot/Projects/bash-intro.workshop
$ mv testing test/
$ ./test/testing
/home/sebastianwaisbrot/Projects/bash-intro.workshop
$ cd test/
$ ./testing
/home/sebastianwaisbrot/Projects/bash-intro.workshop/test
$
```

---

### `$PATH`

Lista de directorios separados por `:` donde se buscan los comandos cada vez que queremos ejecutar
algo. O sea, cada vez que ejecutamos algo en bash, éste busca en cada uno de estos directorios
un archivo ejecutable con ese nombre para invocarlo.

```
$ ls
file2  testing
$ echo 'echo lol' > ls
$ chmod a+x ls
$ export PATH="$PWD:$PATH" # agrego el directorio actual a $PATH
$ ls
lol
$ /bin/ls
file2  ls  testing
$
```

---

## Archivos especiales

### `$HOME/.profile`

Este archivo se ejecuta cuando se inicia un nuevo shell. Suele contener cambios en variables de
entorno, como agregar directorios a `$PATH`.

### `$HOME/.bashrc`

Este archivo se ejecuta cuando se inicia un subshell. Las variables de entorno son heredadas así
que si fueron agregadas en `.profile` no es necesario hacerlo acá. Los aliases no se copian
así que hay que agregarlos en este script.

---

# Tarea

## Buscar directorio en `$PATH`

Hacer una función que reciba una ruta y decir si está en `$PATH`. _Hint:_ `read` soporta un
parámetro `-d` para delimitador.

    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create();
    </script>
  </body>
</html>
